# Makefile

## 前言

在介绍Makefile之前，先来认识一下make。GNU make(简称make)是Linux环境下构建和管理自己工程的强有力工具。在Linux(Unix)下使用GNU的make工具能够比较容易构建任何一个工程，整个工程只需要一个命令就可以完成从编译、链接到最终执行的功能。make命令正常工作的基础就是Makefile文件。

Makefile文件描述了整个工程的编译、链接等相关规则。具体的规则包括：工程中哪些源文件需要编译以及如何编译，需要创建哪些库文件以及如何创建这些库文件，如何产生最终的可执行文件等等。尽管为整个工程编写一个Makefile文件可能会比较耗时，但是为工程提供一个正确的Makefile文件的优势是可以使用一个命令完成”自动化编译“过程，极大提高工程开发效率。

一个Makefile文件编写需要遵守一定的语法规则。其中包括Makefile的书写规则，变量使用规则，条件执行，make运行，make内嵌函数以及make的隐含规则。Linux 0.11内核中的Makefile文件仅使用到了Makefile的普遍规则，因此在本节只介绍Makefile的初级使用规则，更高级的使用规则请参考本小节末的参考文档。

## Makefile总述

### Makefile文件命名

默认情况下，make命令会在当前目录下按顺序找文件名为"GNUmakefile"、"makefile"、"Makefile"的文件，找到了则按照此文件的规则执行相关命令。在这三个文件名中，最好使用"Makefile"这个文件名，这个文件名首字母大写，比较醒目。同时，也可以使用别的文件名来书写Makefile规则，如"Make.Linux"、"Make.Solaris"、"Make.AIX"等，此时在执行make命令时需要指定需要执行的Makefile，使用make的"-f"和"-file"参数即可，如`make -f Make.Linux`或`make -file Make.Linux`。

### Makefile的内容

Makefile中主要包括了五个部分，分别为显式规则、隐晦规则、变量定义、文件指示和注释。

* 显式规则

显式规则说明了如何生成一个或者多个目标文件。由Makefile文件编写者明确指出要生成的文件，文件之间的依赖关系以及生成文件的命令等。

* 隐晦规则

由于make具有自动推导的功能，隐晦规则允许Makefile文件编写者比较粗略地书写部分规则，这是make命令所支持的重要功能。

* 变量定义

在Makefile中允许定义一系列的变量，在Makefile中，变量一般都是字符串，与C语言中的宏定义有些类似。Makefile在被执行时，其中的变量都会被扩展到相应的应用位置上。

* 文件指示

文件指示包括了三个部分。第一部分，可以在一个Makefile中引用另一个Makefile，就像C语言中的include一样；第二部分是可以根据某些情况指定Makefile中的有效部分，就像C语言中的#if一样；第三部分是可以定义一个多行的命令。

* 注释

Makefile中只有行注释，和UNIX的shell脚本一样，其注释是使用"#"字符。如果需要注释多行，则在已注释的"#"行末尾加上"\"即可注释下一行。


## Makefile的规则

首先看一个典型规则的例子：

```
foo.o: foo.c defs.h
    cc -c -g foo.c
```
Makefile中的规则主要包含两个部分，一个是依赖关系，另一个是生成目标的命令。在这个例子中，文件“foo.o”是规则需要重建的文件，而“fooc.c”和“defs.h”是重建“foo.o”所需要的文件。

我们把规则所需要重建的文件叫做规则的目标，把重建需要的文件叫做规则的依赖。例子中的第二行“cc -c -g foo.c”叫做规则的命令，命令描述了如何使用规则中的依赖文件重建目标。

在Makefile中，规则的顺序是很重要的，因为Makefile中有且只有一个最终目标，其他的目标都是终极目标的铺垫。通常来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标也有很多个，那么，第一个规则中的第一个目标将成为最终的目标。

### 规则语法

Makefile文件中通常的规则语法格式如下:

```
TARGETS:PREREQUISITES
    COMMAND
    ...
```
或者

```
TARGETS:PREREQUISITES;COMMAND
    COMMAND
    ...
```

在书写规则时，需要注意以下几点:

1.规则的命令部分有两种书写方式，如以上两种格式。需要特别注意的是，当命令作为独立行时此行必须以[TAB]字符开始。在Makefile中，在第一个规则之后出现的所有以[TAB]字符开始的行都会被当做命令来处理。

2.Makefile中的“$”字符有特殊的含义，通常表示变量和函数的引用，在规则中若需要使用此符号，书写两个连续的字符即可，如“$$”。

一个规则会告诉make命令做两件事情。第一，目标在什么情况下已经过期。第二，如果需要重建目标时，如何去重建这个目标。规则的中心思想是:目标文件的内容是由依赖文件决定的，依赖文件的任何一处改动，将导致目前已经存在的目标文件内容过期。规则的命令为重建目标提供了相应的方法。




## make的运行

一般来说，最简单的就是直接在命令行下输入 make 命令，make 命令会找当前目录的 makefile 来执行，一切都是自动的。但也有时你也许只想让 make 重编译某些文件，而不是 整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。

### make的退出码

make 命令执行后有三个退出码:
0 - 表示成功执行。
1 - 如果 make 运行时出现任何错误，其返回 1。
2 - 如果你使用了 make 的“-q”选项，并且 make 使得一些目标不需要更新，那么返回 2。

### 指定make目标

前面我们说过，GNU make 找寻默认的 Makefile 的规则是在当前目录下依次找三个文件 ——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到， 就开始读取这个文件并执行。
当前，我们也可以给 make 命令指定一个特殊名字的 Makefile。要达到这个功能，我们 要使用 make 的“-f”或是“--file”参数(“--makefile”参数也行)。例如，我们有个 makefile 的名字是“hchen.mk”，那么，我们可以这样来让 make 来执行这个文件:
make –f hchen.mk
如果在 make 的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的 makefile
将会被连在一起传递给 make 执行。

### 检查规则

有时候，我们不想让我们的 makefile 中的规则执行起来，我们只想检查一下我们的命 令，或是执行的序列。于是我们可以使用 make 命令的下述参数:
“-n”
“--just-print”
“--dry-run” “--recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令 打印出来，但不执行，这些参数对于我们调试 makefile 很有用处。
“-t” “--touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make 假 装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。
“-q” “--question”
  这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，
当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。
“-W <file>” “--what-if=<file>” “--assume-new=<file>” “--new-file=<file>”
这个参数需要指定一个文件。一般是是源文件(或依赖文件)，Make 会根据规则推导来 运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件 所发生的规则命令。

## 参考

* **《GNU make中文手册》**

* **《跟我一起写Makefile-陈皓》**

* **《Linux内核完全注释-赵炯》**
